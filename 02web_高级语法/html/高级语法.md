## GIL(全局解释器锁),线程里有，保证多个线程只有一个在执行
### 描述Python GIL的概念
>以及它对python多线程的影响？
编写一个多线程抓取网页的程序，
并阐明多线程抓取程序是否可比单线程性能有提升，并解释原因。
> 1. Python语言和GIL没有半毛钱关系。仅仅是由于历史原因在Cpython虚拟机(解释器)，难以移除GIL。
> 2. GIL：全局解释器锁。每个线程在执行的过程都需要先获取GIL，保证同一时刻只有一个线程可以执行代码。
> 线程释放GIL锁的情况： 在IO操作等可能会引起阻塞的system call之前,可以暂时释放GIL,但在执行完毕后,必须重新获取GIL 
Python3.x使用计时器（执行时间达到阈值后，当前线程释放GIL）或Python 2.x，tickets计数达到100
> 4. Python使用多进程是可以利用多核的CPU资源的。
> 5. 多线程爬取比单线程性能有提升，因为遇到IO阻塞会自动释放GIL锁(会在合适的时间换个线程做)
* 计算密集型（进程，能发挥多核能力）、io密集型（线程、协程）
> 换解释器，不用cPython; 用其他语言代替协程里做的事
### 深拷贝、浅拷贝
* 浅拷贝是对于一个对象的顶层拷贝：拷贝了引用，并没有拷贝内容
* 深拷贝是对于一个对象所有层次的拷贝(递归)
        import copy
        c = copy.copy(a)
        b = copy.deepcopy(a)
* `分片表达式`可以赋值一个序列，属于`浅拷贝`
* copy.copy对于可变类型，会进行浅拷贝
* copy.copy对于不可变类型，`不会拷贝`，`仅仅是指向`，如元组,反正数据也不能修改
* 对于一个全都是不可变类型的数据，深浅一样
* 即便是元组，只要里面包含可变类型数据，深拷贝就还是深拷贝
1. d = c 让d这个变量指向c指向的空间
2. d = copy.copy(c)，复制c指向的数据到新的空间但是不会递归copy
3. d = copy.copy(c)，递归copy

### 私有化
* 父类中属性名为__名字的，子类不继承，子类不能访问
* 如果在子类中向__名字赋值，那么会在子类中定义的一个与父类相同名字的属性
* _名的变量、函数、类在使用from xxx import *时都不会被导入
### 多模块导入注意点

        import aa
        from imp import reload
        reload(aa)

### property属性

### 魔法属性

### 上下文